"""
@author Sina Beier

sb59@sanger.ac.uk

Copyright is owned by the Sanger Institute (Genome Research Ltd.) and Sina Beier

This is a script for detecting patterns in a Pangenome generated by Panakeia.

"""

import argparse
import networkx as nx
import re


def main():
    panG = nx.read_graphml(args.pangenome)
    diaG = nx.read_graphml(args.pangenome)
    extDiaG = nx.read_graphml(args.pangenome)
    periG = nx.read_graphml(args.pangenome)
    extPeriG = nx.read_graphml(args.pangenome)

    name = re.split('/', args.pangenome)[-1]
    name = re.sub("graphML", "", name)
    name = args.directory+"/"+name

    for n in panG.nodes():
        neighbors = panG.neighbors(n)
        if panG.nodes[n]['core'] == 'hard core' or panG.nodes[n]['core'] == 'soft core':
            periG.remove_node(n)
            keep = False
            for x in neighbors:
                if panG.nodes[x]['core'] == 'cloud' or panG.nodes[x]['core'] == 'shell':
                    keep = True
            if not keep:
                extPeriG.remove_node(n)

        if panG.nodes[n]['core'] == 'shell' or panG.nodes[n]['core'] == 'cloud':
            diaG.remove_node(n)
            keep = False
            for x in neighbors:
                if panG.nodes[x]['core'] == 'hard core' or panG.nodes[x]['core'] == 'soft core':
                    keep = True
            if not keep:
                extDiaG.remove_node(n)
    nx.write_graphml(periG, name + "perigenome.graphML")
    nx.write_graphml(extPeriG, name + "extended_perigenome.graphML")
    nx.write_graphml(diaG, name + "diagenome.graphML")
    nx.write_graphml(extDiaG, name + "extended_diagenome.graphML")

    patterns = re.split(",", args.patterns)
    for p in patterns:
        p = re.sub(r'\s', "", p)
        if p == "isolates" or "all":
            isolates(panG, name)
        if p == "unique" or "all":
            uniques(panG, name)
        if p == "variants" or "all":
            variants(panG, name)
        if p == "insertions" or "all":
            insertions(panG, name)
        if p == "indels" or "all":
            indels(extPeriG, name)
        if p == "tabular" or "all":
            writeTable(panG, name)


def isolates(panG, name):
    with open(name+"isolates.txt", 'w') as iso:
        iso.write("cluster\tstrains\tweight\n")
        for n in panG.nodes:
            if panG.degree(n) == 0:
                iso.write(n+"\t"+str(panG.nodes[n]['strains'])+"\t"+str(panG.nodes[n]['weight'])+"\n")


def uniques(panG, name):
    with open(name+"uniques.txt", 'w') as u:
        u.write("cluster\tdegree\tweight\n")
        for n in panG.nodes:
            if panG.nodes[n]['strains'] == 1:
                u.write(n+"\t"+str(panG.degree(n))+"\t"+str(panG.nodes[n]['weight'])+"\n")


def variants(panG, name):
    cycles = nx.cycle_basis(panG)
    nodes = set()
    with open(name + "variants.txt", 'w') as vars:
        all_variants = list()
        for c in cycles:
            variant = list()
            if len(c) == 4 or len(c) == 3:
                for n in c:
                    nodes.add(n)
                    deg = panG.degree(n)
                    if deg == 2:
                        variant.append(n)
                if len(variant) > 1:
                    all_variants.append(variant)

        cycleG = panG.subgraph(nodes)
        nx.write_graphml(cycleG, name + "variants.graphML")
        for v1 in all_variants:
            for v2 in all_variants:
                if v1 != v2:
                    intersect = list(set(v1) & set(v2))
                    if len(intersect) > 0:
                        new_v1= list(set(v1).union(set(v2)))
                        if v1 in all_variants:
                            all_variants.remove(v1)
                        if v2 in all_variants:
                            all_variants.remove(v2)
                        all_variants.append(new_v1)
        for v in all_variants:
            vars.write('\t'.join(v) + "\n")


def insertions(panG, name):
    with open(name + "InsertionSequences.txt", 'w') as IS:
        IS.write("cluster\tdegree\tweight\n")
        nodes = list()
        for n in panG.nodes():
            deg = nx.degree(panG, n)
            if deg > 3:
                IS.write(n+"\t"+str(deg)+"\t"+str(panG.nodes[n]['weight'])+"\n")
                nodes.append(n)
                for x in panG.neighbors(n):
                    if panG.nodes[x]['core'] == 'shell' or panG.nodes[x]['core'] == 'cloud':
                        nodes.append(x)
        insertionG = panG.subgraph(nodes)
        nx.write_graphml(insertionG, name + "InsertionSequences.graphML")


def indels(extPeriG, name):
    newPeriG = extPeriG.copy()
    ns = extPeriG.nodes()
    for n in ns:
        if extPeriG.degree(n) > 4:
            newPeriG.remove_node(n)
    cycles = nx.cycle_basis(newPeriG)
    nodes = set()
    with open(name + "Indels.txt", 'w') as ins:
        for c in cycles:
            cycle = list()
            if len(c) > 4:
                for n in c:
                    nodes.add(n)
                    cycle.append(n)
                cyc = '\t'.join(cycle)
                ins.write(cyc+"\n")
    cycleG = extPeriG.subgraph(nodes)
    nx.write_graphml(cycleG, name + "Indels.graphML")


def writeTable(panG, name):
    degree = nx.degree(panG)
    av_neighbor_deg = nx.average_neighbor_degree(panG)
    close_centrality = nx.closeness_centrality(panG)
    betweenness_centrality = nx.betweenness_centrality(panG)
    ccomps = nx.connected_components(panG)
    eccentricity = dict()
    for c in ccomps:
        comp = panG.subgraph(c)
        e = nx.eccentricity(comp)
        for ec in e:
            eccentricity[ec] = e[ec]

    with open(name + "tabular.tsv", 'w') as t:
        t.write("cluster\tdegree\taverage_neighbor_degree\tclose_centrality\tbetweenness_centrality\teccentricity\n")
        for n in panG.nodes():
            l = list()
            l.append(n)
            l.append(str(degree[n]))
            l.append(str(av_neighbor_deg[n]))
            l.append(str(close_centrality[n]))
            l.append(str(betweenness_centrality[n]))
            l.append(str(eccentricity[n]))
            s = '\t'.join(l)
            t.write(s+"\n")


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("pangenome", help="Pangenome GraphML")
    parser.add_argument("directory", help="Output directory")
    parser.add_argument("patterns", help="Comma separated list of pattern types to search for")
    args = parser.parse_args()
    main()
